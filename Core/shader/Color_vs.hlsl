/*-------------------------------------------------------------------------------------------
* 이것이 첫 번째 셰이더 프로그램이 될 것입니다. 
* 셰이더는 모델의 실제 렌더링을 수행하는 작은 프로그램입니다. 
* 이러한 셰이더는 HLSL로 작성되며 color.vs 및 color.ps라는 소스 파일에 저장됩니다. 
* 지금은 .cpp 및 .h 파일과 함께 엔진에 파일을 배치했습니다. 
* Visual studio에서 새 필터/폴더를 만들어야 한다는 점에 유의하세요. 
* 그리고 셰이더를 마우스 오른쪽 버튼으로 클릭하고 "속성"을 선택하면 
* 팝업에서 콘텐츠 섹션에 아무것도 없어야 하고 항목 유형 섹션에 
* "빌드에 참여하지 않음"이라고 표시되어야 하며 그렇지 않으면 주 진입점에 
* 대한 컴파일 오류가 발생합니다.
-------------------------------------------------------------------------------------------*/
// Vertex Shader


/*-------------------------------------------------------------------------------------------
* 셰이더 프로그램에서는 전역 변수로 시작합니다. 
* 이러한 전역 변수는 C++ 코드에서 외부에서 수정할 수 있습니다. 
* int나 float와 같은 다양한 유형의 변수를 사용한 다음 
* 셰이더 프로그램에서 사용할 수 있도록 외부에서 설정할 수 있습니다. 
* 일반적으로 대부분의 전역 변수는 하나의 전역 변수일지라도 
* "cbuffer"라는 버퍼 객체 유형에 넣습니다. 이러한 버퍼를 
* 논리적으로 구성하는 것은 셰이더의 효율적인 실행과 
* 그래픽 카드가 버퍼를 저장하는 방식에 중요합니다. 
* 이 예제에서는 매 프레임마다 동시에 업데이트할 것이므로 
* 동일한 버퍼에 세 개의 행렬을 넣었습니다.
-------------------------------------------------------------------------------------------*/
cbuffer MatrixBuffer
{
    matrix world;
    matrix view;
    matrix projection;
};


/*-------------------------------------------------------------------------------------------
* C와 마찬가지로 우리만의 타입 정의를 만들 수 있습니다. 
* 셰이더를 더 쉽고 읽기 쉽게 프로그래밍할 수 있도록 
* HLSL에서 사용할 수 있는 float4와 같은 다양한 유형을 사용하겠습니다. 
* 이 예제에서는 x, y, z, w 위치 벡터와 
* 빨강, 초록, 파랑, 알파 색상이 있는 유형을 생성합니다. 
* POSITION, COLOR, SV_POSITION은 변수의 사용을 
* GPU에 전달하는 시맨틱입니다. 버텍스 셰이더와 픽셀 셰이더는 
* 구조체가 같더라도 의미가 다르기 때문에 
* 여기서 두 개의 다른 구조를 만들어야 합니다. 
* 버텍스 셰이더에는 POSITION이, 픽셀 셰이더에는 SV_POSITION이 작동하며 
* COLOR는 두 가지 모두에 작동합니다. 
* 같은 유형의 셰이더가 두 개 이상 필요한 경우 끝에 
* COLOR0, COLOR1 등과 같은 숫자를 추가해야 합니다.
-------------------------------------------------------------------------------------------*/
struct VertexInputType
{
    float4 position : POSITION;
    float4 color : COLOR;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float4 color : COLOR;
};


/*-------------------------------------------------------------------------------------------
* 버텍스 셰이더는 GPU가 전송된 버텍스 버퍼의 데이터를 처리할 때 호출됩니다. 
* 이 버텍스 셰이더는 버텍스 버퍼의 모든 단일 버텍스에 대해 호출됩니다. 
* 버텍스 셰이더에 대한 입력은 버텍스 버퍼의 데이터 형식과 
* 셰이더 소스 파일의 유형 정의(이 경우 VertexInputType)와 일치해야 합니다. 
* 버텍스 셰이더의 출력은 픽셀 셰이더로 전송됩니다. 이 경우 출력 유형은 
* 위에 정의된 PixelInputType이라고 합니다. 이를 염두에 두면 버텍스 셰이더가 
* PixelInputType 유형의 출력 변수를 생성하는 것을 알 수 있습니다. 그런 다음 
* 입력 버텍스의 위치를 가져와 월드, 뷰, 투영 행렬을 곱합니다. 이렇게 하면 
* 뷰에 따라 3D 공간에서 2D 화면에 렌더링할 수 있는 올바른 위치에 
* 버텍스가 배치됩니다. 그 후 출력 변수는 입력 색의 복사본을 가져온 다음 
* 픽셀 셰이더의 입력으로 사용될 출력을 반환합니다. 또한 입력 위치의 W값을
* 1.0으로 설정했는데, 그렇지 않으면 위치에 대한 XYZ 벡터만 읽어오기 때문에 정의되지 않습니다.
-------------------------------------------------------------------------------------------*/
PixelInputType ColorVertexShader(VertexInputType input)
{
    PixelInputType output;
    
    // 적절한 행렬 계산을 위해 위치 벡터를 4단위로 변경합니다
    input.position.w = 1.0f;
    
    // 월드, 뷰, 투영 행렬에 대한 버텍스의 위치 계산하기
    output.position = mul(input.position, world);
    output.position = mul(input.position, view);
    output.position = mul(projection, input.position);

    return (output);
}
